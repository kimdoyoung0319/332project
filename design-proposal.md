Design Proposal
---
## Terminologies and Definitions
* **Record**: 
  Each line, which consists of a key and value, in input files which are 
  generated by gensort.
* **Block**: 
  A file that has certain, designated amounts of records.
* **Chunk**:
  A file that has undeterminned amounts of records.
* **Partition**: 
  A certain range of keys, like [begin, end). It can sometimes refer to an block
  that holds the records that are in the partition. For example, when a sentence
  says "A partition [x, y) is sent to another worker machine...", what it 
  actually says is "A block that holds records within partition [x, y) is sent 
  to...".
* **Histogram**:
  A data structure that maps a range to the number of records in the range. For
  example, it can be thought as a `Seq` of pairs like 
  `Seq(Range(1, 3), 4), (Range(4, 5), 5))`, or `Map` from a range to number like
  `Map(Range(1, 3) -> 4, Range(4, 5) -> 5)`.
  - `Range` constructor is used to define a range. `Range(start, end)` is 
    equivalent to [start, end).

## Data Structures

### Scala Classes and Objects

#### `class Record`
A record object represents a record in the file produced by gensort. It consists
of two integer values, `key` and `value`. It also has comparator methods (or, 
operators) like `<`, `>`, `<=`, `>=` defined to convenient comparison between
them while sorting. The comparison between records shall be done only by their
keys in lexicographical order. i.e. 
`Record(key = 34, value = 50) > Record(key = 12, value = 70)` must return 
`true` even if the value of the latter one is greater.

#### `class Range`
A range is a pair of two keys, representing a range of keys. It consists of two
integer values, `begin` and `end` and represents a half-opened range [begin, 
end). i.e. It does *not* contains the `end` key. It also has `contains` method
that takes a key as argument and returns if this range contains the key or not. 
For instance, `Range(4, 5) contains 5` should return `false` and 
`Range(1, 100) contains 50` should return `true`.

### Protobuf Services and Messages

#### `Sampling`
Has an remote procedure `askSample`.

##### `sampleRequest`
A request to each worker machines to sample each blocks and reply with whole
histogram of records. 

Q. What field should a `sampleRequest` hold?

##### `sampleReply`

#### `Sorting`
Has a remote procedure `askSort`.

<!-- TODO: Define the messages that represents a sort request and done reply. -->

#### `Shuffling`
Has a remote procedure `sendChunk` which sends a chunk and returns 
acknowlegment to ensure the chunk has been sent successfully.

<!-- TODO: Define the messages that represents a chunk and acknowledgement. -->

#### `Merging`
Has a remote procedure `askMerge`.

## Phases
The whole procedure will be..
1. Scan whole records in each worker machine, making a histogram.
2. Compute appropriate partition for each worker machines.
  - If it failed to derive appropriate ranges, goto 1 and make a histogram with 
    narrower ranges.
3. Sort each blocks in each worker machine concurrently.
4. Determine the partition where each records should go into, and send the 
   chunks corresponding to the partition.
5. Merge each blocks in each worker machines, creating a chunk of whole sorted
   records. 

Hence, we split the whole procedure into phases, which are units of tasks that
depends on one another. Because the phases depends on one another, their orders
must not be changed. In other words, a set of phases must be executed 
sequentially, while each phases can be executed concurrently.

### Sample Phase
The sample phase corresponds to step 1, 2 in above procedure.

### Sort Phase

### Shuffle Phase

### Merge Phase
