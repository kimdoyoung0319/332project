Design Proposal
---
## Terminologies and Definitions
* **Record**: 
  Each line, which consists of a key and value, in input files which are 
  generated by gensort.
* **Block**: 
  A file that has certain, designated amounts of records.
* **Chunk**:
  A file that has undeterminned amounts of records.
* **Partition**: 
  A certain range of keys, like [begin, end). It can sometimes refer to an block
  that holds the records that are in the partition. For example, when a sentence
  says "A partition [x, y) is sent to another worker machine...", what it 
  actually says is "A block that holds records within partition [x, y) is sent 
  to...".

## Data Structures

### Scala Classes and Objects

#### `class Record`
A record object represents a record in the file produced by gensort. It consists
of two integer values, `key` and `value`. It also has comparator methods (or, 
operators) like `<`, `>`, `<=`, `>=` defined to convenient comparison between
them while sorting. The comparison between records shall be done only by their
keys in lexicographical order. i.e. 
`Record(key = 34, value = 50) > Record(key = 12, value = 70)` must return 
`true` even if the value of the latter one is greater.

#### `class Range`
<!-- TODO: Is it really needed? -->
A range is a pair of two keys, representing a range of keys. It consists of two
integer values, `begin` and `end` and represents a half-opened range [begin, 
end). i.e. It does *not* contains the `end` key. It also has `contains` method
that takes a key as argument and returns if this range contains the key or not. 
For instance, `Range(4, 5) contains 5` should return `false` and 
`Range(1, 100) contains 50` should return `true`.

#### `class Block`
A block is a file with designated size, which can be sorted. It has private
member that refers to the path to this block. Also, it has functional `sorted` 
method which sorts this block and returns another block that is sorted and 
copied into the temporary directory. For example, If 
`Block("input/file.1").sorted() == Block("output/tmp/partition.1")`, then
the result of sorting `input/file.1` is stored in `output/tmp/partition.1`.

### Protobuf Services and Messages

#### `SortingService`
<!-- TODO: Is an acknowledgement signal needed? -->
In `SortingService` service, there is a remote procedure whose name is 
`startSort()`. `startSort()` takes no argument and retuns `done` 
message. `done` is a dummy return value indicating that the sorting 
procedure in each worker machine is finished.

#### `SamplingService`
In `SamplingService` service, there is a remote procedure whose name is 
`requestSamples`. `requestSamples()` takes `sampleRequest` message which holds 
the number of samples as an argument, returning the `sampleResponse` message 
which holds the actual samples.

#### `Shuffling`
Has a remote procedure `sendChunk` which sends a chunk and returns 
acknowlegment to ensure the chunk has been sent successfully.

<!-- TODO: Define the messages that represents a chunk and acknowledgement. -->

#### `Merging`
Has a remote procedure `askMerge`.

## Phases
The whole procedure will be..
1. Sort each blocks in each worker machine concurrently.
2. Scan whole records in each worker machine, making the samples.
3. Compute appropriate partition for each worker machines.
  - If it failed to derive appropriate ranges, goto 1 and make a histogram with 
    narrower ranges.
4. Determine the partition where each records should go into, and send the 
   chunks corresponding to the partition.
5. Merge each blocks in each worker machines, creating a chunk of whole sorted
   records. 

Hence, we split the whole procedure into phases, which are units of tasks that
depends on one another. Because the phases depends on one another, their orders
must not be changed. In other words, a set of phases must be executed 
sequentially, while each phases can be executed concurrently.

### Sort Phase
In this sorting phase, each worker machine starts sorting each blocks in its own
input directories. The master sends start signal to each workers as a remote
procedure call and the workers send done signal by the return `Future` of the
remote procedure.

The workers internally sorts each blocks in the input directory. It first has
to recognize all the blocks in the input directory. Then, it assigns the sorting
task to designated number of thread, or `Future` blocks so that each threads
can sort those blocks concurrently. If one thread get its job done, the worker's
main thread should re-assign a sorting task to each `Future`.

If all `Future` got its job done and there's no remaining block to be sorted,
then the sorting phase of the worker is finished. Then it sends (above 
mentioned) done signal back to the master.

The new file name of those sorted block should be `file.sorted` if the original
file name was `file`. If the input file was `data1/input/hello` and the output
directory is `/output/`, then the full path to the sorted file shall be 
`/output/tmp/data1/input/hello.sorted`.

### Sample Phase
In this sample phase, each worker machine takes a sample of input dataset and 
sends it to master machine. In each blocks, the worker machine takes certain
number of samples and merge them into a chunk of records. Then the worker sends
this chunk. The master machine takes this chunks of each worker machines and 
merge them into a chunk. Finally, the master machine sorts the chunk and divide
the whole key range into ranges assigned to each worker machine.

When taking n samples among N records in a block, the worker takes 0th, 
k th, 2k th, ..., nk th records where k = N / n. The workers only picks the
key value of each records since the value is useless when deciding the partition
range.

After sorting in the master machine, it decides the whole partitions of the 
worker machines from [Chunk(0), Chunk(n / 10)), 
[Chunk(n / 10), Chunk(2 * n / 10)), ..., [Chunk(9 * n / 10), Chunk(n)) where
we denote n th element of the sorted chunk by Chunk(n).

### Shuffle Phase

### Merge Phase
